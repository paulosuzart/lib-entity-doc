import{_ as o,c as r,a0 as e,b as s,w as i,a1 as d,B as l,o as a,G as c,a as A}from"./chunks/framework.BeGZUZv7.js";const C=JSON.parse('{"title":"What is LibEntity?","description":"","frontmatter":{},"headers":[],"relativePath":"guide.md","filePath":"guide.md"}'),u={name:"guide.md"};function m(g,t,f,h,p,y){const n=l("Mermaid");return a(),r("div",null,[t[1]||(t[1]=e('<h1 id="what-is-libentity" tabindex="-1">What is LibEntity? <a class="header-anchor" href="#what-is-libentity" aria-label="Permalink to &quot;What is LibEntity?&quot;">​</a></h1><p>LibEntity is a powerful (and fun!) Java library for building type-safe, state-driven business entities with validation and action handling. It provides a clean, expressive DSL for defining entities, their states, fields, and actions. It&#39;s like Spring Boot for your business rules, but with more good vibes and less boilerplate!</p><h2 id="lib-entity-vs-traditional-hexagonal-architecture" tabindex="-1">lib-entity vs Traditional Hexagonal Architecture <a class="header-anchor" href="#lib-entity-vs-traditional-hexagonal-architecture" aria-label="Permalink to &quot;lib-entity vs Traditional Hexagonal Architecture&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Feature/Aspect</th><th>lib-entity</th><th>Traditional Hexagonal Architecture (Hand-Made)</th></tr></thead><tbody><tr><td><strong>Boilerplate</strong></td><td>Minimal: most patterns, wiring, and validation are handled by the framework</td><td>High: manual wiring, repetitive code, lots of classes</td></tr><tr><td><strong>Business Logic Focus</strong></td><td>DSL lets you focus on rules, states, and actions, not on plumbing</td><td>Business logic often mixed with infrastructure code</td></tr><tr><td><strong>Extensibility</strong></td><td>Easily add actions, validations, fields, or states declaratively</td><td>Requires manual changes across multiple layers</td></tr><tr><td><strong>Validation &amp; Actions</strong></td><td>Built-in, composable, and reusable via DSL</td><td>Custom, often duplicated, and scattered</td></tr><tr><td><strong>Testability</strong></td><td>Entities and actions are isolated, easy to mock and test</td><td>Test setup is verbose, mocking can be complex</td></tr><tr><td><strong>Consistency</strong></td><td>Enforced by the framework and DSL, less room for error</td><td>Depends on developer discipline</td></tr><tr><td><strong>Learning Curve</strong></td><td>Beginner-friendly, especially for new team members</td><td>Steep: must learn patterns, best practices, wiring</td></tr><tr><td><strong>DSL/Declarative</strong></td><td>Fluent, type-safe, and self-documenting</td><td>Imperative, verbose, and error-prone</td></tr><tr><td><strong>Integration</strong></td><td>Out-of-the-box integration with Spring, validation, and more</td><td>Must integrate and maintain dependencies manually</td></tr><tr><td><strong>Maintainability</strong></td><td>High: changes in one place, less code rot</td><td>Medium/Low: changes ripple through many files</td></tr></tbody></table><h2 id="metamodel" tabindex="-1">Metamodel <a class="header-anchor" href="#metamodel" aria-label="Permalink to &quot;Metamodel&quot;">​</a></h2><p>A metamodel is a model of a model. In the context of LibEntity, a metamodel is a model of your entity types. The prebuilt metamodel brings structure to your services while keeping good flexibility and a exit path at any point in time.</p><p>A metamodel is what allows you to move fast. Most systems are &quot;literal&quot;, that means they are too granular, and you end up with a lot of code, a lot of testing surface, and a lot of maintenance burdern that blocks your business to react fast. LibEntity metamodel is a balance between granularity and simplicity.</p><p>LibEntity metamodel is as follows:</p>',8)),(a(),s(d,null,{default:i(()=>[c(n,{id:"mermaid-148",class:"mermaid",graph:"classDiagram%0A%20%20%20%20class%20ActionExecutor%20%7B%0A%20%20%20%20%20%20%20%20%3C%3Cinterface%3E%3E%0A%20%20%20%20%20%20%20%20%2Bexecute(currentState%2C%20request%2C%20ctx%2C%20command)%0A%20%20%20%20%20%20%20%20%2BgetAllowedActions(currentState%2C%20request)%0A%20%20%20%20%7D%0A%0A%20%20%20%20class%20EntityType%20%7B%0A%20%20%20%20%20%20%20%20%2Bname%3A%20String%0A%20%20%20%20%20%20%20%20%2Bfields%3A%20Map%3CString%2C%20FieldDefinition%3E%0A%20%20%20%20%20%20%20%20%2Bactions%3A%20Map%3CString%2C%20ActionDefinition%3E%0A%20%20%20%20%20%20%20%20%2BgetActions()%0A%20%20%20%20%20%20%20%20%2BgetFieldDefinitions()%0A%20%20%20%20%7D%0A%0A%20%20%20%20class%20EntityTypeBuilder%20%7B%0A%20%20%20%20%20%20%20%20%2Bfield(name%2C%20type%2C%20config)%0A%20%20%20%20%20%20%20%20%2Baction(name%2C%20config)%0A%20%20%20%20%20%20%20%20%2Bbuild()%0A%20%20%20%20%7D%0A%0A%20%20%20%20class%20FieldDefinition%20%7B%0A%20%20%20%20%20%20%20%20%2Bname%3A%20String%0A%20%20%20%20%20%20%20%20%2Btype%3A%20Class%0A%20%20%20%20%20%20%20%20%2Bvalidators%3A%20List%3CValidator%3E%0A%20%20%20%20%20%20%20%20%2BstateTransitionValidators%3A%20Map%0A%20%20%20%20%20%20%20%20%2BvalidateInState(state%2C%20validator)%0A%20%20%20%20%20%20%20%20%2BvalidateStateTransition(from%2C%20to%2C%20validator)%0A%20%20%20%20%7D%0A%0A%20%20%20%20class%20ActionDefinition%20%7B%0A%20%20%20%20%20%20%20%20%2Bname%3A%20String%0A%20%20%20%20%20%20%20%20%2BcommandType%3A%20Class%0A%20%20%20%20%20%20%20%20%2BallowedStates%3A%20Set%3CS%3E%0A%20%20%20%20%20%20%20%20%2BonlyIf%3A%20Predicate%0A%20%20%20%20%20%20%20%20%2Bhandler%3A%20ActionHandler%0A%20%20%20%20%20%20%20%20%2Bexecute(state%2C%20request%2C%20command%2C%20ctx)%0A%20%20%20%20%20%20%20%20%2Bvalidate(state%2C%20request%2C%20command%2C%20ctx)%0A%20%20%20%20%7D%0A%0A%20%20%20%20class%20ActionCommand%20%7B%0A%20%20%20%20%20%20%20%20%3C%3Cinterface%3E%3E%0A%20%20%20%20%20%20%20%20%2BgetActionName()%3A%20String%0A%20%20%20%20%7D%0A%0A%20%20%20%20class%20ActionResult%20%7B%0A%20%20%20%20%20%20%20%20%2Bstate%3A%20S%0A%20%20%20%20%20%20%20%20%2Brequest%3A%20R%0A%20%20%20%20%20%20%20%20%2Bcommand%3A%20C%0A%20%20%20%20%7D%0A%0A%20%20%20%20class%20ValidationContext%20%7B%0A%20%20%20%20%20%20%20%20%2BaddError(code%2C%20message)%0A%20%20%20%20%20%20%20%20%2BhasErrors()%0A%20%20%20%20%20%20%20%20%2BgetErrors()%0A%20%20%20%20%7D%0A%0A%20%20%20%20class%20Validator%20%7B%0A%20%20%20%20%20%20%20%20%3C%3Cinterface%3E%3E%0A%20%20%20%20%20%20%20%20%2Bvalidate(state%2C%20request%2C%20ctx)%0A%20%20%20%20%7D%0A%0A%20%20%20%20class%20StateTransitionValidator%20%7B%0A%20%20%20%20%20%20%20%20%3C%3Cinterface%3E%3E%0A%20%20%20%20%20%20%20%20%2Bvalidate(fromState%2C%20toState%2C%20request%2C%20ctx)%0A%20%20%20%20%7D%0A%0A%20%20%20%20EntityType%20%221%22%20--%20%22*%22%20FieldDefinition%3A%20has%0A%20%20%20%20EntityType%20%221%22%20--%20%22*%22%20ActionDefinition%3A%20has%0A%20%20%20%20EntityTypeBuilder%20--%3E%20EntityType%3A%20builds%0A%20%20%20%20ActionDefinition%20--%3E%20ActionCommand%3A%20accepts%0A%20%20%20%20ActionDefinition%20--%3E%20ActionResult%3A%20produces%0A%20%20%20%20ActionDefinition%20--%3E%20ValidationContext%3A%20uses%0A%20%20%20%20FieldDefinition%20--%3E%20Validator%3A%20uses%0A%20%20%20%20FieldDefinition%20--%3E%20StateTransitionValidator%3A%20uses%0A%20%20%20%20ActionExecutor%20--%3E%20EntityType%3A%20operates%20on%0A%20%20%20%20ActionExecutor%20--%3E%20ValidationContext%3A%20uses%0A%20%20%20%20ActionExecutor%20--%3E%20ActionResult%3A%20returns%0A%20%20%20%20ActionCommand%20--%3E%20ActionDefinition%3A%20triggers%0A"})]),fallback:i(()=>t[0]||(t[0]=[A(" Loading... ")])),_:1})),t[2]||(t[2]=e('<h3 id="core-pieces" tabindex="-1">Core Pieces <a class="header-anchor" href="#core-pieces" aria-label="Permalink to &quot;Core Pieces&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody><tr><td><strong>ActionExecutor</strong></td><td>Interface for executing actions based on incoming commands and the current state of the entity.</td></tr><tr><td><strong>EntityType</strong></td><td>Core configuration of an entity, containing fields, actions, and their definitions.</td></tr><tr><td><strong>EntityTypeBuilder</strong></td><td>DSL builder for fluently configuring entities with fields, actions, and validations.</td></tr><tr><td><strong>FieldDefinition</strong></td><td>Defines a field&#39;s type, validators, and state transition rules.</td></tr><tr><td><strong>ActionDefinition</strong></td><td>Defines an action&#39;s command type, allowed states, conditions (onlyIf), and handler.</td></tr><tr><td><strong>ActionCommand</strong></td><td>Interface for commands that trigger actions on entities.</td></tr><tr><td><strong>ActionResult</strong></td><td>Result of an action execution containing new state, modified request, and command.</td></tr><tr><td><strong>ValidationContext</strong></td><td>Collects validation errors during action execution and field validation.</td></tr><tr><td><strong>Validator</strong></td><td>Interface for field validators that run in specific states.</td></tr><tr><td><strong>StateTransitionValidator</strong></td><td>Interface for validators that run during state transitions.</td></tr></tbody></table><blockquote><p><strong>Summary:</strong> &gt; <code>lib-entity</code> lets you build robust, maintainable, and testable domain logic with far less code and cognitive overhead. You get all the benefits of Hexagonal Architecture, but with a declarative, beginner-friendly approach and much less boilerplate. Perfect for teams who value both flexibility and productivity.</p></blockquote>',3))])}const B=o(u,[["render",m]]);export{C as __pageData,B as default};
