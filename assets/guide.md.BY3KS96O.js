import{_ as e,c as a,a0 as i,o as n}from"./chunks/framework.DX7EX5Ix.js";const h=JSON.parse('{"title":"What is LibEntity?","description":"","frontmatter":{},"headers":[],"relativePath":"guide.md","filePath":"guide.md"}'),r={name:"guide.md"};function o(d,t,s,l,c,u){return n(),a("div",null,t[0]||(t[0]=[i('<h1 id="what-is-libentity" tabindex="-1">What is LibEntity? <a class="header-anchor" href="#what-is-libentity" aria-label="Permalink to &quot;What is LibEntity?&quot;">​</a></h1><p>LibEntity is a powerful (and fun!) Java library for building type-safe, state-driven business entities with validation and action handling. It provides a clean, expressive DSL for defining entities, their states, fields, and actions. It&#39;s like Spring Boot for your business rules, but with more good vibes and less boilerplate!</p><h2 id="lib-entity-vs-traditional-hexagonal-architecture" tabindex="-1">lib-entity vs Traditional Hexagonal Architecture <a class="header-anchor" href="#lib-entity-vs-traditional-hexagonal-architecture" aria-label="Permalink to &quot;lib-entity vs Traditional Hexagonal Architecture&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Feature/Aspect</th><th>lib-entity</th><th>Traditional Hexagonal Architecture (Hand-Made)</th></tr></thead><tbody><tr><td><strong>Boilerplate</strong></td><td>Minimal: most patterns, wiring, and validation are handled by the framework</td><td>High: manual wiring, repetitive code, lots of classes</td></tr><tr><td><strong>Business Logic Focus</strong></td><td>DSL lets you focus on rules, states, and actions, not on plumbing</td><td>Business logic often mixed with infrastructure code</td></tr><tr><td><strong>Extensibility</strong></td><td>Easily add actions, validations, fields, or states declaratively</td><td>Requires manual changes across multiple layers</td></tr><tr><td><strong>Validation &amp; Actions</strong></td><td>Built-in, composable, and reusable via DSL</td><td>Custom, often duplicated, and scattered</td></tr><tr><td><strong>Testability</strong></td><td>Entities and actions are isolated, easy to mock and test</td><td>Test setup is verbose, mocking can be complex</td></tr><tr><td><strong>Consistency</strong></td><td>Enforced by the framework and DSL, less room for error</td><td>Depends on developer discipline</td></tr><tr><td><strong>Learning Curve</strong></td><td>Beginner-friendly, especially for new team members</td><td>Steep: must learn patterns, best practices, wiring</td></tr><tr><td><strong>DSL/Declarative</strong></td><td>Fluent, type-safe, and self-documenting</td><td>Imperative, verbose, and error-prone</td></tr><tr><td><strong>Integration</strong></td><td>Out-of-the-box integration with Spring, validation, and more</td><td>Must integrate and maintain dependencies manually</td></tr><tr><td><strong>Maintainability</strong></td><td>High: changes in one place, less code rot</td><td>Medium/Low: changes ripple through many files</td></tr></tbody></table><blockquote><p><strong>Summary:</strong> &gt; <code>lib-entity</code> lets you build robust, maintainable, and testable domain logic with far less code and cognitive overhead. You get all the benefits of Hexagonal Architecture, but with a declarative, beginner-friendly approach and much less boilerplate. Perfect for teams who value both flexibility and productivity.</p></blockquote>',5)]))}const b=e(r,[["render",o]]);export{h as __pageData,b as default};
